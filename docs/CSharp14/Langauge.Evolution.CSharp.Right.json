{
  "aiEngine2": {
    "versions": [
      {
        "version": "Introduction & Background",
        "year": "2025",
        "article": "Discriminated unions—also known as sum types or tagged unions—are a staple of functional languages like F#, Haskell, and Rust. They let you define a type that can be one of many named alternatives, each possibly carrying its own data. This enables clearer domain models and compiler-enforced exhaustiveness. In C#, developers have long emulated these patterns with inheritance, enums, records, and libraries, but native support is still not part of the language."
      },
      {
        "version": "2025 Status Check: C# 14 / .NET 10 / VS 2026",
        "year": "2025",
        "article": "Visual Studio 2026 Insiders released with first-class support for .NET 10 and C# 14. C# 14 focuses on pragmatic additions such as extension members (aka “extension everything”), implicit span conversions, and null-conditional assignment, plus assorted quality-of-life changes. Discriminated unions are not in C# 14; they remain under active design and discussion."
      },
      {
        "version": "Current Approximations in C#",
        "year": "2025",
        "article": "Because native discriminated unions are not yet available in C#, developers rely on libraries and patterns. The OneOf<T1, T2, …> library offers union-like types with Match/Switch helpers and compile-time guidance. Other approaches include sealed record hierarchies with pattern matching, or bespoke result types (e.g., Result<TSuccess, TError>). These work well but can be verbose and don’t provide built-in exhaustiveness checks."
      },
      {
        "version": "State of Proposals and Design",
        "year": "2025",
        "article": "There’s an ongoing proposal in the dotnet/csharplang repo to introduce union/type-union capabilities. Recent design notes suggest a phased approach (e.g., union classes first) with continuing discussion on syntax, semantics, and tooling. Despite interest, no union feature shipped in C# 14; consideration appears to be for a future release."
      },
      {
        "version": "Benefits of Native Support",
        "year": "2025",
        "article": "Native unions would improve domain modeling and safety. APIs could return explicit alternatives (e.g., Result.Success or Result.Error) with compiler-verified handling, reducing runtime errors and clarifying control flow across large codebases."
      },
      {
        "version": "Design Challenges",
        "year": "2025",
        "article": "Key challenges include choosing a syntax that complements records/enums/classes, ensuring good performance (tagging, allocations, codegen), and integrating with runtime features like reflection, serialization, and debugging. Tooling and IDE experience must feel natural alongside pattern matching."
      },
      {
        "version": "Use Cases",
        "year": "2025",
        "article": "Strong candidates include API result types, command processing, workflow/state machines, parsers, and configuration schemas—areas where closed sets of alternatives and exhaustive handling reduce edge-case bugs and improve readability."
      },
      {
        "version": "Probability Outlook",
        "year": "2025",
        "article": "C# 14 (with .NET 10) did not include unions. Based on public discussion and the phased design direction, the odds look better for a post-C# 14 release (e.g., C# 15 or later). A cautious estimate: low likelihood for 2025 GA, moderate likelihood in the next major cycle if design complexities are resolved."
      },
      {
        "version": "Approval Process",
        "year": "2025",
        "article": "New C# features advance via proposals in dotnet/csharplang and review in Language Design Meetings. After sufficient consensus, features progress through prototypes and previews before GA, aligned with .NET release planning and IDE/tooling readiness."
      },
      {
        "version": "Conclusion",
        "year": "2025",
        "article": "Discriminated unions remain a highly requested feature that would align C# with functional strengths seen in F# and others. C# 14 shipped other meaningful improvements but not unions. Continued design activity keeps unions credible for a future release, pending final decisions on syntax, ergonomics, performance, and tooling."
      }
    ]
  }
}
